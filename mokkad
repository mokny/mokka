#!/usr/bin/python3
import threading
import time
import uuid
import random
from multiprocessing.connection import Listener, Client
from contextlib import closing
import socket
import os
import signal
import psutil
import sys
import datetime
import shutil
import subprocess 
import tomllib
import ssl
import zipfile
import venv
import json

from http.server import BaseHTTPRequestHandler, HTTPServer
from urllib.parse import urlparse
from urllib.request import urlretrieve

tlock = threading.Lock()
starttime = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

class VarHolder(object):
    def info():
        print('Just a dummy')
sys.modules["varholder"] = VarHolder

import varholder as v

v.modules = {}
v.apiserver = False

class Module(threading.Thread):
    def __init__(self, workspace, ident):  
        threading.Thread.__init__(self)
        self.workspace = workspace.upper()
        self.moduleident = ident.upper()
        self.output = []
        self.ps = False
        self.process = None
        self.config = moduleGetConfig(pathModule(workspace, ident))
        v.modules[self.workspace + '/' + self.moduleident] = self

    def run(self):
        cmd = 'bin/python ' + self.config['GENERAL']['exec']
        value = 'ping -c 10 localhost' 
        value = cmd
        try:
            os.environ["PYTHONUNBUFFERED"] = "1"
            self.process = subprocess.Popen(value.split(' '), stdout = subprocess.PIPE, stdin = subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, preexec_fn=os.setsid, cwd=pathModule(self.workspace, self.moduleident))
            self.ps = psutil.Process(self.process.pid)
            while True:
                line = self.process.stdout.readline()
                self.process.stdout.flush()
                if not line:
                    break
                self.output.append(line.rstrip())
                if len(self.output) > 1000:
                    self.output = self.output[1:]

            err = self.process.stderr.read()          
            if err:
                self.output.append(str(err))
                pass

            self.output.append('--END--')
        except Exception as err:
            self.output.append(str('-- END WITH ERR ' + str(err) + ' --'))
            print(err)
            pass
        
        with tlock:
            del v.modules[self.workspace + '/' + self.moduleident]


class APIServer(BaseHTTPRequestHandler):
    def do_GET(self):
        self.handler()

    def headers_okay(self):
        self.send_response(200)
        self.send_header("Content-type", "text/json")
        self.end_headers()

    def headers_badrequest(self):
        self.send_response(400)
        self.end_headers()

    def out(self, data):
        self.wfile.write(bytes(json.dumps(data), "utf-8"))

    def handler(self):
        try:
            response = {}
            pt = self.path.split('/')
            if pt[1].lower() == 'api':
                if pt[2].lower() == 'ps':
                    self.headers_okay()
                    response['API'] = {
                        'VERSION': '1.0',
                        'REQUEST': self.path,
                        'TIMESTAMP': time.time()
                    }
                    response['MODULES'] = {}
                    for m in v.modules:
                        response['MODULES'][m] = {
                            'ident': v.modules[m].moduleident,
                            'workspace': v.modules[m].workspace,
                            'pid': v.modules[m].process.pid,
                            'outputlen': len(v.modules[m].output),
                            'data': {
                                'cpu_time': v.modules[m].ps.cpu_times().system,
                                'cpu_percent': v.modules[m].ps.cpu_percent() / psutil.cpu_count(),
                                'status': v.modules[m].ps.status(),
                            }
                        }
                    self.out(response)
                elif pt[2].lower() == 'status':
                    self.headers_okay()
                    response['API'] = {
                        'VERSION': '1.0',
                        'REQUEST': self.path,
                        'TIMESTAMP': time.time()
                    }
                    response['STATUS'] = {
                        'STARTED': starttime,
                        'VERSION': '0.0.1'
                    }
                    self.out(response)
                else:
                    self.headers_badrequest()
                
            else:
                self.headers_badrequest()
        except:
            self.headers_badrequest()

    def log_message(self, format, *args):
        return


class IPCServer(threading.Thread):
    def __init__(self, port, secret):  
        threading.Thread.__init__(self)
        self.port = port
        self.secret = secret

    def run(self):
        address = ('127.0.0.1', self.port)     # family is deduced to be 'AF_INET'
        listener = Listener(address, authkey=str.encode(str(self.secret)))
        while True:
            con = listener.accept()
            c = IPCIncomingConnection(con)
            c.start()
    

    
class IPCIncomingConnection(threading.Thread):
    def __init__(self, conn):  
        threading.Thread.__init__(self)
        self.conn = conn
        self.workspace = 'DEFAULT'
        self.ismodule = False
        self.module = False
        
    def run(self):
        msg = ''
        while True:
            try:
                msg = self.conn.recv()
                with tlock:
                    if isinstance(msg, list):
                        if len(msg) > 0:
                            
                            # Quit the Daemon
                            if msg[0] == "-q":
                                self.disconnect()
                                os._exit(0)
                            
                            # Restart the Daemon
                            if msg[0] == "-r":
                                os.system("nohup "+sys.executable+" mokkad >/dev/null 2>&1 &")
                                self.disconnect()
                                os._exit(0)

                            # Version
                            if msg[0] == "-v":
                                self.output("0.0.1 b1")
                                self.disconnect()

                            # Help
                            elif msg[0] == "-h":
                                self.output('-h                                 Help')
                                self.output('-q                                 Quit MOKKA Daemon')
                                self.output('-s                                 Enter Shell')
                                self.output('-v                                 Version')
                                self.output('WORKSPACE CREATE <IDENT>           Create Workspace')
                                self.output('WORKSPACE REMOVE <IDENT>           Create Workspace')
                                self.output('WORKSPACE LIST                     Create Workspace')
                                self.output('INSTALL <WS> <PATH/URL>            Install module from local path')
                                self.output('RUN <WS> <IDENT>                   Run module')
                                self.output('REMOVE <WS> <IDENT>                Remove module')
                                self.output('LOG <WS> <IDENT>                   Get module logs')
                                self.output('PS                                 Running modules')
                                self.disconnect()
                            
                           
                            # Install Module
                            elif msg[0].lower() == "install":
                                if len(msg) == 3:
                                    moduleInstall(msg[1], msg[2], self)
                                self.disconnect()
                            
                            # Remove Module
                            elif msg[0].lower() == "remove":
                                if len(msg) == 3:
                                    moduleRemove(msg[1], msg[2])
                                self.disconnect()
                            
                            # Run Module
                            elif msg[0].lower() == "run":
                                if len(msg) == 3:
                                    if moduleRun(msg[1], msg[2]):
                                        self.output('Running')
                                    else:
                                        self.output('Not a module')
                                else:
                                    self.output('Use RUN <WORKSPACE> <IDENT>')
                                self.disconnect()
                            
                            # List running modules
                            elif msg[0].lower() == "ps":
                                for mident in v.modules:
                                    self.output(mident + ' ' + v.modules[mident].config['GENERAL']['title'])
                                self.disconnect()
                            
                            elif msg[0].lower() == "log":
                                if len(msg) == 3:
                                    log = moduleGetLog(msg[1], msg[2])
                                    for i in log:
                                        self.output(i)
                                self.disconnect()

                            # Workspace
                            elif msg[0].lower() == "workspace" or msg[0].lower() == "ws":
                                if len(msg) >= 2:

                                    # Create workspace
                                    if msg[1].lower() == "create" or msg[1].lower() == "cr":
                                        if len(msg) == 3:
                                            workspace = msg[2].upper()
                                            if not workspace == '.' and not workspace == '..':
                                                if not os.path.isdir(pathWorspace(workspace)):
                                                    self.output("Creating Workspace " + workspace)
                                                    os.mkdir(pathWorspace(workspace))
                                                    self.output("Done.")
                                                else:
                                                    self.output("Workspace already exists.")
                                            else:
                                                self.output("Invalid workspace ident.")
                                        else:
                                            self.output("Invalid syntax. Use WORKSPACE CREATE <IDENT>")
                                    
                                    # Remove workspace
                                    elif msg[1].lower() == "remove" or msg[1].lower() == "rm":
                                        if len(msg) == 3:
                                            workspace = msg[2].upper()
                                            if not workspace == '.' and not workspace == '..':
                                                if os.path.isdir(pathWorspace(workspace)):
                                                    self.output("Removing Workspace " + workspace)
                                                    shutil.rmtree(pathWorspace(workspace))
                                                    self.output("Done.")
                                                else:
                                                    self.output("Workspace does not exist.")
                                            else:
                                                self.output("Invalid workspace ident.")
                                        else:
                                            self.output("Invalid syntax. Use WORKSPACE CREATE <IDENT>")
                                    
                                    # List workspaces
                                    elif msg[1].lower() == "list" or msg[1].lower() == "ls":
                                        self.output("Workspaces:")
                                        for workspace in os.listdir(pathBase()):
                                            if os.path.isdir(pathWorspace(workspace)):
                                                if not workspace.startswith('.'):
                                                    self.output(workspace)
                                        self.output("")

                                    elif msg[1].lower() == "help":
                                        self.output("WORKSPACE")
                                        self.output("   LIST or LS            - List all workspaces")
                                        self.output("   CREATE or CR <IDENT>  - Create a new workspace")
                                        self.output("   REMOVE or RM <IDENT>  - Remove a workspace")

                                    else:
                                        self.output("Invalid syntax. Use WORKSPACE HELP")
                                else:
                                        self.output("Invalid syntax. Use WORKSPACE HELP")
                                self.disconnect()

                            # Internal shell
                            elif msg[0] == "-s":
                                self.output(' ___ ___   ___   __  _  __  _   ____ ')
                                self.output('|   |   | /   \\ |  |/ ]|  |/ ] /    |')
                                self.output('| _   _ ||     ||    / |    / |  o  |')
                                self.output('|  \\_/  ||  O  ||    \\ |    \\ |     |')
                                self.output('|   |   ||     ||     \\|     \\|  _  |')
                                self.output('|   |   ||     ||  .  ||  .  ||  |  |')
                                self.output('|___|___| \\___/ |__|\\_||__|\\_||__|__|')                              
                                self.output('Multi processing / IPC framework')
                                self.output('by Till Vennefrohne')
                                self.output('Daemon startet at ' + str(starttime) + ' / PID: ' + str(os.getpid()))
                                self.output('Welcome to the shell. Type Q to exit')
                                self.output('')
                                while True:
                                    response = self.getInput('> ').strip()

                                    if response.lower() == 'q':
                                        self.disconnect()
                                        break

                                    elif response.lower() == 'r':
                                        self.disconnect()
                                        os.system("nohup "+sys.executable+" mokkad >/dev/null 2>&1 &")
                                        os._exit(0)

                                    elif response.lower() == 'help':
                                        self.output('Q      Exit shell')
                                        self.output('R      Restart Daemon')

                                    else:
                                        self.output('Unknown command ' + response + '. Use HELP.')
                            
                            # Invalid command
                            else:
                                print(msg)
                                self.output('Unknown command. Use -h')
                                self.disconnect()

                        else:
                            print(msg)
                            self.output('Unknown command. Use -h')
                            self.disconnect()

            except Exception as err:
                print(err)
                try:
                    self.output('Error:' + err)
                except:
                    pass
                self.conn.close()
                break

    def getInput(self, query):
        self.send('INPUT', query)
        return self.conn.recv()

    def output(self, message):
        self.send('OUTPUT', message)

    def send(self, method, payload):
        self.conn.send({'method': method, 'payload': payload})

    def disconnect(self):
        self.conn.close()

def is_url(url):
    return urlparse(url).scheme in ('http', 'https',)

def pathUser():
    return os.path.expanduser('~')

def pathBase():
    pb = os.path.join(os.path.expanduser('~'), 'mokkabase')
    if not os.path.isdir(pb):
        os.mkdir(pb)
    return pb

def pathTmpDir():
    pb = os.path.join(pathBase(), '.tmp')
    if not os.path.isdir(pb):
        os.mkdir(pb)
    return pb

def pathWorspace(workspace):
    pb = os.path.join(os.path.expanduser('~'), 'mokkabase', workspace)
    return pb

def pathModule(workspace, ident):
    pb = os.path.join(os.path.expanduser('~'), 'mokkabase', workspace, ident)
    return pb

def moduleGetConfig(source):
    with open(os.path.join(os.path.join(source, 'mokka.toml')), "r") as f:
        tomlraw = f.read()
    return tomllib.loads(tomlraw)

def moduleExists(workspace, ident):
    if os.path.isdir(os.path.join(pathWorspace(workspace),ident)):
        return True
    return False

def moduleInstall(workspace, source, client = False):
    if not os.path.isdir(pathWorspace(workspace.upper())):
        if client: client.output("Workspace " + workspace.upper() + ' does not exist')
        return False
    
    tmpdir = False

    if is_url(source):
        if not str(source).lower().endswith('.zip'):
            if client: client.output('Only ZIP files supported')
            return False
        fn = str(uuid.uuid4())
        try:
            urlretrieve(source, os.path.join(pathTmpDir(), fn + '.zip'))
        except:
            if client: client.output('Unable to download file')
            return False
        try:
            with zipfile.ZipFile(os.path.join(pathTmpDir(), fn + '.zip'), 'r') as zip_ref:
                zip_ref.extractall(os.path.join(pathTmpDir(), fn))
        except:
            if client: client.output('Unable to extract zip file')
            os.remove(os.path.join(pathTmpDir(), fn + '.zip'))
            return False

        os.remove(os.path.join(pathTmpDir(), fn + '.zip'))
        
        tmpdir = os.path.join(pathTmpDir(), fn)
        source = tmpdir

    if os.path.isdir(source):
        if client: client.output('Installing from ' + source)
        err = moduleHasErrors(source)
        if err: 
            if client: client.output(err)
            if tmpdir: shutil.rmtree(tmpdir)
        else:
            if client: client.output('Source check OK.')
            config = moduleGetConfig(source)
            if moduleExists(workspace.upper(), config['GENERAL']['ident']):
                if client: client.output('Module already exists')
                if tmpdir: shutil.rmtree(tmpdir)
                return False
            shutil.copytree(source, os.path.join(pathWorspace(workspace.upper()), config['GENERAL']['ident'].upper()))
            if client: client.output('Creating virtual environment...')
            venv.create(os.path.join(pathWorspace(workspace.upper()), config['GENERAL']['ident'].upper()))
            if client: client.output('Installing PIP...')
            subprocess.check_call([os.path.join(pathWorspace(workspace.upper()), config['GENERAL']['ident'].upper(),'bin','python'), '-m' , 'ensurepip', '--default-pip'])            
            if 'INSTALL' in config:
                if 'piplibs' in config['INSTALL']:
                    for piplib in config['INSTALL']['piplibs']:
                        if client: client.output('Installing '+piplib+'...')
                        subprocess.check_call([os.path.join(pathWorspace(workspace.upper()), config['GENERAL']['ident'].upper(),'bin','python'), "-m", "pip", "install", piplib])
            
            if client: client.output('Module installed')
            return True
    else:
        if client: client.output(source + ' not found.')
        if tmpdir: shutil.rmtree(tmpdir)
        return False

def moduleRemove(workspace, ident):
    if os.path.isdir(os.path.join(pathWorspace(workspace.upper()),ident.upper())):
        shutil.rmtree(os.path.join(pathWorspace(workspace.upper()),ident.upper()))
        return True
    return False

def moduleRun(workspace, ident):
    if os.path.isdir(os.path.join(pathWorspace(workspace.upper()),ident.upper())):
        Module(workspace.upper(), ident.upper()).start()
        return True
    return False

def moduleGetLog(workspace, ident):
    mident = workspace.upper() + '/' + ident.upper()
    if mident in v.modules:
        return v.modules[mident].output
    
def moduleHasErrors(source):
    if os.path.isfile(os.path.join(source, 'mokka.toml')):
        try:
            with open(os.path.join(os.path.join(source, 'mokka.toml')), "r") as f:
                tomlraw = f.read()
            config = tomllib.loads(tomlraw)
            configok = False
            if 'GENERAL' in config:
                if 'title' in config['GENERAL']:
                    if 'ident' in config['GENERAL']:
                        if 'exec' in config['GENERAL']:
                            configok = True
                        else:
                            return "Invalid mokka.toml"    
                    else:
                        return "Invalid mokka.toml"    
                else:
                    return "Invalid mokka.toml"    
            else:
                return "Invalid mokka.toml"

            if configok:
                if not os.path.isfile(os.path.join(os.path.join(source, config['GENERAL']['exec']))):
                    return "Exec file is missing."
                return False
            
        except Exception as err:
            return "Invalid mokka.toml" + os.path.join(os.path.join(source, 'mokka.toml')) + str(err)
    else:
        return "mokka.toml missing"
    return False



def setup():
    # Kill older instances by name
    pid = os.getpid()
    for p in psutil.process_iter():
        if p.name().lower() == 'python':
            cmdl = p.cmdline()
            try:
                if cmdl[0].lower().endswith('/python'):
                    if cmdl[1].lower() == 'mokkad':
                        if pid != p.pid:
                            print("Old instance of Daemon was terminated. Only one instance allowed.")
                            os.kill(p.pid,signal.SIGTERM)
            except:
                pass

    # Jump into program dir as CWD
    os.chdir(os.path.dirname(os.path.abspath(__file__)))

    # Create dir in user home dir
    cwd = pathBase()
    
    # Create Port-File
    with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as s:
        s.bind(('', 0))
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        port = s.getsockname()[1]
        with open(os.path.join(cwd,'.port'), "w") as f:
            f.write(str(port))

    # Create Secret-File
    secret = str(uuid.uuid4()) + '/' + str(time.time()) + '/' + str(random.randint(100000,999999999))
    with open(os.path.join(cwd,'.secret'), "w") as f:
        f.write(secret)

    return port, secret

def init():
    ssl._create_default_https_context = ssl._create_unverified_context
    port, secret = setup()
    print("IPC-Port: " + str(port))
    print("IPC-Secret: " + str(secret))
    server = IPCServer(port, secret)
    server.start()

    print("API-Server: http://127.0.0.1:45662/api")
    v.apiserver = HTTPServer(('127.0.0.1', 45662), APIServer)

    try:
        v.apiserver.serve_forever()
    except:
        pass

    while server.is_alive():
        time.sleep(0.1)

init()