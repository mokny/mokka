#!/usr/bin/python3
import threading
import time
import uuid
import random
from multiprocessing.connection import Listener, Client
from contextlib import closing
import socket
import os
import signal
import psutil
import sys
import datetime
import shutil
import subprocess 
import tomllib
import ssl
import zipfile
import venv
import json

from http.server import BaseHTTPRequestHandler, HTTPServer
from urllib.parse import urlparse
from urllib.request import urlretrieve
from urllib.request import urlopen

VERSION = ['0','1','1']

tlock = threading.Lock()
starttime = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
mainconfig = {}

class VarHolder(object):
    def info():
        pass
sys.modules["varholder"] = VarHolder

import varholder as v

v.modules = {}
v.pids = {}
v.eventreceivers = {}
v.apiserver = False
v.options = {}

class Module(threading.Thread):
    def __init__(self, workspace, ident):  
        threading.Thread.__init__(self)
        self.workspace = workspace.upper()
        self.moduleident = ident.upper()
        self.output = []
        self.ps = False
        self.process = None
        self.config = moduleGetConfig(pathModule(workspace, ident))
        self.eventpipe = False
        self.pid = False
        self.killflag = False
        v.modules[self.workspace + '/' + self.moduleident] = self

    def kill(self):
        self.killflag = True
        try:
            self.process.kill()
        except:
            pass

    def run(self):
        if not self.killflag:
            cmd = 'bin/python ' + self.config['GENERAL']['exec']
            value = 'ping -c 10 localhost' 
            value = cmd
            try:
                os.environ["PYTHONUNBUFFERED"] = "1"

                self.process = subprocess.Popen(value.split(' '), stdout = subprocess.PIPE, stdin = subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, preexec_fn=os.setsid, cwd=pathModule(self.workspace, self.moduleident))
                self.ps = psutil.Process(self.process.pid)
                self.pid = self.process.pid

                v.pids['p'+str(self.pid)] = self

                while not self.killflag:
                    line = self.process.stdout.readline()
                    self.process.stdout.flush()
                    if not line:
                        break
                    self.output.append(line.rstrip())
                    if len(self.output) > 1000:
                        self.output = self.output[1:]

                err = self.process.stderr.read()          
                if err:
                    self.output.append(str(err))
                    pass

                self.output.append('--END--')
            except Exception as err:
                self.output.append(str('-- END WITH ERR ' + str(err) + ' --'))
                print(err)
                pass
        
        with tlock:
            if self.workspace + '/' + self.moduleident in v.modules:
                del v.modules[self.workspace + '/' + self.moduleident]
            if 'p'+str(self.pid) in v.pids:
                del v.pids['p'+str(self.pid)] 


class APIServer(BaseHTTPRequestHandler):
    def do_GET(self):
        self.handler()

    def headers_okay(self):
        self.send_response(200)
        self.send_header("Content-type", "text/json")
        self.end_headers()

    def headers_badrequest(self):
        self.send_response(400)
        self.end_headers()

    def out(self, data):
        self.wfile.write(bytes(json.dumps(data), "utf-8"))

    def handler(self):
        try:
            response = {}
            pt = self.path.split('/')
            if pt[1].lower() == 'api':
                if pt[2].lower() == 'ps':
                    self.headers_okay()
                    response['API'] = {
                        'VERSION': '1.0',
                        'REQUEST': self.path,
                        'TIMESTAMP': time.time()
                    }
                    response['MODULES'] = {}
                    for m in v.modules:
                        response['MODULES'][m] = {
                            'ident': v.modules[m].moduleident,
                            'workspace': v.modules[m].workspace,
                            'pid': v.modules[m].process.pid,
                            'outputlen': len(v.modules[m].output),
                            'data': {
                                'cpu_time': v.modules[m].ps.cpu_times().system,
                                'cpu_percent': v.modules[m].ps.cpu_percent() / psutil.cpu_count(),
                                'status': v.modules[m].ps.status(),
                            }
                        }
                    self.out(response)
                elif pt[2].lower() == 'status':
                    self.headers_okay()
                    response['API'] = {
                        'VERSION': '1.0',
                        'REQUEST': self.path,
                        'TIMESTAMP': time.time()
                    }
                    response['STATUS'] = {
                        'STARTED': starttime,
                        'VERSION': '0.0.1'
                    }
                    self.out(response)
                else:
                    self.headers_badrequest()
                
            else:
                self.headers_badrequest()
        except:
            self.headers_badrequest()

    def log_message(self, format, *args):
        return


class IPCServer(threading.Thread):
    def __init__(self, port, secret):  
        threading.Thread.__init__(self)
        self.port = port
        self.secret = secret

    def run(self):
        address = ('127.0.0.1', self.port)     # family is deduced to be 'AF_INET'
        listener = Listener(address, authkey=str.encode(str(self.secret)))
        while True:
            con = listener.accept()
            c = IPCIncomingConnection(con)
            c.start()
    

    
class IPCIncomingConnection(threading.Thread):
    def __init__(self, conn):  
        threading.Thread.__init__(self)
        self.conn = conn
        self.workspace = 'DEFAULT'
        self.ismodule = False
        self.module = False
        self.pid = False

    def run(self):
        msg = ''
        while True:
            try:
                msg = self.conn.recv()
                with tlock:
                    if isinstance(msg, list):
                        if len(msg) > 0:
                            
                            # Quit the Daemon
                            if msg[0] == "-q":
                                self.disconnect()
                                os._exit(0)
                            
                            # Restart the Daemon
                            if msg[0] == "-r":
                                os.system("nohup "+sys.executable+" mokkad >/dev/null 2>&1 &")
                                self.disconnect()
                                os._exit(0)

                            # Version
                            if msg[0] == "-v":
                                self.output('.'.join(VERSION))
                                self.disconnect()

                            # Help
                            elif msg[0] == "-h":
                                self.output('-h                                 Help')
                                self.output('-q                                 Quit MOKKA Daemon')
                                self.output('-s                                 Enter Shell')
                                self.output('-v                                 Version')
                                self.output('WORKSPACE CREATE <IDENT>           Create Workspace')
                                self.output('WORKSPACE REMOVE <IDENT>           Remove workspace')
                                self.output('WORKSPACE LIST                     List available workspaces')
                                self.output('MODULES <WS>                       List installed modules in workspace')
                                self.output('INSTALL <WS> <PATH/URL>            Install module from local path')
                                self.output('RUN <WS> <IDENT>                   Run module')
                                self.output('REMOVE <WS> <IDENT>                Remove module')
                                self.output('LOG <WS> <IDENT>                   Get module logs')
                                self.output('KILL <WS> <IDENT>                  Kill a module')
                                self.output('KILLALL                            Kill all running modules')
                                self.output('PS                                 Running modules')
                                self.output('SEARCH                             Search on marketplace')
                                self.output('EVENT                              Trigger event')
                                self.output('EVENTPIPES                         List all eventpipes')
                                self.output('SETOPT <WS> <MOD> <OPT> <VALUE>    Set an option for a module')
                                self.output('GETOPT <WS> <MOD> <OPT>            Get an option from a module')
                                self.disconnect()
                            
                            # Information
                            elif msg[0].lower() == "info":
                                self.output('Version ' + '.'.join(VERSION))
                                self.output('by Till Vennefrohne')
                                self.output('Daemon startet at ' + str(starttime) + ' / PID: ' + str(os.getpid()))
                                self.disconnect()

                            # Install Module
                            elif msg[0].lower() == "install":
                                if len(msg) == 3:
                                    moduleInstall(msg[1], msg[2], self)
                                self.disconnect()
                            
                            # Kill Module
                            elif msg[0].lower() == "kill":
                                if len(msg) == 3:
                                    moduleKill(msg[1], msg[2])
                                self.disconnect()
                            
                            # Remove Module
                            elif msg[0].lower() == "remove":
                                if len(msg) == 3:
                                    moduleRemove(msg[1], msg[2])
                                self.disconnect()
                            
                            # Run Module
                            elif msg[0].lower() == "run":
                                if len(msg) == 3:
                                    if moduleRun(msg[1], msg[2]):
                                        self.output('Running')
                                    else:
                                        self.output('Not a module')
                                else:
                                    self.output('Use RUN <WORKSPACE> <IDENT>')
                                self.disconnect()

                            # Set Option
                            elif msg[0].lower() == "setopt":
                                if len(msg) >= 5:
                                    if is_int(' '.join(msg[4:])):
                                        value = int(' '.join(msg[4:]))
                                    elif is_float(' '.join(msg[4:])):
                                        value = float(' '.join(msg[4:]))
                                    else:
                                        value = ' '.join(msg[4:])
                                    setOption(msg[1].upper(), msg[2].upper(), msg[3].upper(), value)
                                else:
                                    self.output('Use setopt <WORKSPACE> <MODULE> <OPTION> <VALUE>')
                                self.disconnect()
                            
                            # Get Option
                            elif msg[0].lower() == "getopt":
                                if len(msg) == 4:
                                    option = getOption(msg[1].upper(), msg[2].upper(), msg[3].upper())
                                    self.output(option)
                                else:
                                    self.output('Use getopt <WORKSPACE> <MODULE> <OPTION>')
                                self.disconnect()
                            
                            # List running modules
                            elif msg[0].lower() == "ps":
                                for mident in v.modules:
                                    self.output(mident + ' ' + v.modules[mident].config['GENERAL']['title'] + ' ' + str(v.modules[mident].process.pid) + ' ' + str(len(v.modules[mident].output)))
                                self.disconnect()
                            
                            # Get module logs
                            elif msg[0].lower() == "log":
                                if len(msg) == 3:
                                    log = moduleGetLog(msg[1], msg[2])
                                    for i in log:
                                        self.output(i)
                                self.disconnect()

                            # Trigger event
                            elif msg[0].lower() == "event":
                                eventTrigger('blaaaa', False, 'bluuub')
                                self.disconnect()

                            # Eventpipes
                            elif msg[0].lower() == "eventpipes":
                                for pid in v.pids:
                                    if v.pids[pid].eventpipe:
                                        self.output(str(pid) + ' ' + str(v.pids[pid].workspace+ ' ' + str(v.pids[pid].moduleident)))

                                self.disconnect()

                            # Kill all modules
                            elif msg[0].lower() == "killall":
                                moduleKillAll()
                                self.disconnect()

                            # Get module logs
                            elif msg[0].lower() == "search":
                                if len(msg) >= 1:
                                    results = marketSearch(' '.join(msg[1:]))
                                    for res in results:
                                        self.output('-> ' + res['ident'] + ' - ' + res['title'])
                                if len(results) == 0: self.output("No results")
                                self.disconnect()

                            # List modules in workspace
                            elif msg[0].lower() == "modules" or msg[0].lower() == "mods":
                                if len(msg) == 2:
                                    for fmodule in os.listdir(pathWorspace(msg[1].upper())):
                                        if os.path.isdir(os.path.join(pathWorspace(msg[1].upper()), fmodule)):
                                            if not fmodule.startswith('.'):
                                                if moduleIsRunning(msg[1], fmodule):
                                                    self.output(fmodule + ' (Running)')
                                                else:
                                                    self.output(fmodule)
                                self.disconnect()

                            #frida
                            elif msg[0].lower() == "frida":
                                self.output('▓▓▒▒░▒▒▒▓▓▓░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░▒▒▒▒▒▒▒▒▒▒▓▒▒▓▒▒▒▒▒▒▓▓███▓▓▓▓▓▒▓▓▓▓▓▓▓▓▒▓▓')
                                self.output('▓▒▒▒▒▒░▒▒▒▓▒░░░░░░░░░▒▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒░░░▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▓██████▓▓▒▓▓▓▓████▓▓▓▒')
                                self.output('▓▓▓▓▒▒▒▒▓▒▒░░░▒░░░░░▓▓██▓▓██▓▓▓▒▒▒▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒▓██████▓▓▓▓▓████████▓▓')
                                self.output('▓▓▓▓▒▓▓▓▓▓▒░░░▒░░░▒▓▓▓▓▓▓▓▓███████▓▓▓▓▒▒▒▒▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓███████▓▒▓█████████▓▒▒')
                                self.output('▓▒▒▓▓▒▓▓▒▒░░░░░░▒▓▓██▓▓▓▓▓▓▓▓▓████████▓▓█████████▓▓▒▒▒▒▒▒▒▒▒▓▒▒▒▒▓▓███████▓▓██████████▓▓▓▓')
                                self.output('▒▒▓▓▓▓▓▓▓▒░░░░░▒▓██████▓▓▓▓▓███████████████▓▓▓████████▓▓▓▓▓▓▓▓▒▒▓▓██████████████████▓▓▓▓▓▓')
                                self.output('▓▓▓▓▓▓▓▓▓▒░░░▒▒▓█▓███▓▓▓▓▓██████████████▓▒▒░░▒▒▓▓▓███████████████████████████████▓▓▓▓▓▓▓▓▓')
                                self.output('▓▓▓▓▓▓▓▓▓░░░▒▒▓▓▓▓███████████████████████▓▓▓▓████████████████████████████████▓▓▓▓▓▓▓▓▓▓▓▓▓')
                                self.output('▓▒▓▓▓▓▓▓▒░░░▓▓▓▓▓██████████████████████████████████████████████████████████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓')
                                self.output('▓▓▓▓▓▓▓▓▒░░▒▓▓█▓▓██████▓▓▓▓████▓▓█████████████████████████████████████████████████▓██▓▓▓▓▓')
                                self.output('▓▓▓▓▓▓▓▓▒░░░▓▓▓▓▓███▓▓▓▓▓▓███▓▒▓▓▓▓▓▓█████████████████████████████████████████████████████')
                                self.output('▒▒▒▓▓▓▓▓░░░▒▓▓▓▓▓▓▓▓▓▓▓▓███████████▓██████████████████████████████████████████████████████')
                                self.output('▒▒▒▓▓▓▓▒░░▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██████▓▓▓██████▓▓▓▓▓▓▓▓▓▓▒███████████████████████████████████▓')
                                self.output('▓▓▓▓▓▓▓░░░▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓▓▓▓▓▓▓▓█▓▓▓▓▓▓▓▓▓▓▓▒▓███████████████████████████████▓█▓▒▓')
                                self.output('▓▓▓▓▓▓▓░░░▓███▓▓▓▓▓▓▓▓████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█▓▓▓▓▓▓▓▓██████████████████▓████▓▓▓▓█▓▓█████')
                                self.output('▒▓▓▓█▓▓░░▒▓▓▓▓▓▓▓▓▓▓▓▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█████████████████████▓▓▓▓▓██████████████')
                                self.output('▒▒▒▓▓▓▒░░▒▓▓███▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██████▓▓▓▓▓████████▓▓▓██████████████████████▓▓███▓')
                                self.output('▒▒▒▒▓▒▒░░▒▒█▓▓▓▓▓▓▓▓▓▓▓█▓▓▓▓▓▓▓███▓▓▓▓▓████████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██████████████████████▒▒▓█▓█')
                                self.output('▒▒▒▒▒▓▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█████▓▓▓█████████████▓████▓██████████████████████████▓▓▓████')
                                self.output('▒▒▒▒░▒▒▓▓▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓███▓███▓▒▓▓▓▓▓▓▓███████████████████████████████████████████▓████')
                                self.output('▒▒▒░░░▒▒▒▒▒▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▒▓▓▓▒▓▓██████████████████████████████████████████████▓▓▓▓▓▓')
                                self.output('▒▒▒▒░░▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████▓▓▒▓████████████████████████████████████████████████▓▓▓▓▓')
                                self.output('▒▒▒▒▒░▒▒▒▒▓▒▒▓▓█▓▓▓▓▓▓▓▓█▓▓▓▓████████████████████████████████████████████████████████▓▓▓▓▓')
                                self.output('▒▒▒▒▒▒▒▒▒▒▓▒▒▓█████▓██████████████████████████████████████████████████████████████████████')
                                self.output('▒▒▒▒▒▒▒░░▒▒▒▒▒▓███████████████████████████████████████████████████████████████████████████')
                                self.output('▒▒▒▒▒▒░▒░▒▒▒░▒▒▓▓▓▓████████████████▓▓▓▓▓▓▓████████████████████████████████████████████████')
                                self.output('▒▒▒▒▒▒░░▒░░░▒▒▒▒▒▓▓▓█████▓▓▓▓▓▓▓▓▓▓▓██████████████████████████████████████████████████████')
                                self.output('▒▒▒▒▒░░▒░░░░▒▒▒▒▒▒▓███████▓▓▓▓▓▓▓▓█████████████████████████████████████████████████████▓▓▓')
                                self.output('▓▓▒▒▒▒▓░░░░▒▒▒▒▒▒▒░▓▓█████▓▓▓▓▓▓▓▓▓▓███▓▓▓▓▓▓▓▓████▓█████████████████████▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒')
                                self.output('▓▒▒▒▒▓▓▒▒░░▒▓▒░░▒░▒▓▓▓█████▓▓▓▓▓▓▓▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████████████████▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒')
                                self.output('▒▒▒▒▒▓▓▒▒▓▒▒▓▓▒░▒▒▒▓▓▓▒▓██████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▒▒▒▒▒▒▒▒▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒')
                                self.output('▒▒▒▒▒▓▓▒▒▒▒▒▓██▒▒▒▒▒▒▒▒▒▓█████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓')
                                self.output('▓▒▒░▒▒▒▒▒▒▓▒▓█▓▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒')
                                self.disconnect()
                                
                            # Workspace
                            elif msg[0].lower() == "workspace" or msg[0].lower() == "ws":
                                if len(msg) >= 2:

                                    # Create workspace
                                    if msg[1].lower() == "create" or msg[1].lower() == "cr":
                                        if len(msg) == 3:
                                            workspace = msg[2].upper()
                                            if not workspace == '.' and not workspace == '..':
                                                if not os.path.isdir(pathWorspace(workspace)):
                                                    self.output("Creating Workspace " + workspace)
                                                    os.mkdir(pathWorspace(workspace))
                                                    self.output("Done.")
                                                else:
                                                    self.output("Workspace already exists.")
                                            else:
                                                self.output("Invalid workspace ident.")
                                        else:
                                            self.output("Invalid syntax. Use WORKSPACE CREATE <IDENT>")
                                    
                                    # Remove workspace
                                    elif msg[1].lower() == "remove" or msg[1].lower() == "rm":
                                        if len(msg) == 3:
                                            workspace = msg[2].upper()
                                            if not workspace == '.' and not workspace == '..':
                                                if os.path.isdir(pathWorspace(workspace)):
                                                    self.output("Removing Workspace " + workspace)
                                                    shutil.rmtree(pathWorspace(workspace))
                                                    self.output("Done.")
                                                else:
                                                    self.output("Workspace does not exist.")
                                            else:
                                                self.output("Invalid workspace ident.")
                                        else:
                                            self.output("Invalid syntax. Use WORKSPACE CREATE <IDENT>")
                                    
                                    # List workspaces
                                    elif msg[1].lower() == "list" or msg[1].lower() == "ls":
                                        self.output("Workspaces:")
                                        for workspace in os.listdir(pathBase()):
                                            if os.path.isdir(pathWorspace(workspace)):
                                                if not workspace.startswith('.'):
                                                    self.output(workspace)
                                        self.output("")

                                    elif msg[1].lower() == "help":
                                        self.output("WORKSPACE")
                                        self.output("   LIST or LS            - List all workspaces")
                                        self.output("   CREATE or CR <IDENT>  - Create a new workspace")
                                        self.output("   REMOVE or RM <IDENT>  - Remove a workspace")

                                    else:
                                        self.output("Invalid syntax. Use WORKSPACE HELP")
                                else:
                                        self.output("Invalid syntax. Use WORKSPACE HELP")
                                self.disconnect()

                            # Internal shell
                            elif msg[0] == "-s":
                                self.output(' ___ ___   ___   __  _  __  _   ____ ')
                                self.output('|   |   | /   \\ |  |/ ]|  |/ ] /    |')
                                self.output('| _   _ ||     ||    / |    / |  o  |')
                                self.output('|  \\_/  ||  O  ||    \\ |    \\ |     |')
                                self.output('|   |   ||     ||     \\|     \\|  _  |')
                                self.output('|   |   ||     ||  .  ||  .  ||  |  |')
                                self.output('|___|___| \\___/ |__|\\_||__|\\_||__|__|')                              
                                self.output('Multi processing / IPC framework')
                                self.output('Version ' + '.'.join(VERSION))
                                self.output('by Till Vennefrohne')
                                self.output('Daemon startet at ' + str(starttime) + ' / PID: ' + str(os.getpid()))
                                self.output('Welcome to the shell. Type Q to exit')
                                self.output('')
                                while True:
                                    response = self.getInput('> ').strip()

                                    if response.lower() == 'q':
                                        self.disconnect()
                                        break

                                    elif response.lower() == 'r':
                                        self.disconnect()
                                        os.system("nohup "+sys.executable+" mokkad >/dev/null 2>&1 &")
                                        os._exit(0)

                                    elif response.lower() == 'help':
                                        self.output('Q      Exit shell')
                                        self.output('R      Restart Daemon')

                                    else:
                                        self.output('Unknown command ' + response + '. Use HELP.')
                            
                            # Invalid command
                            else:
                                print(msg)
                                self.output('Unknown command. Use -h')
                                self.disconnect()

                        else:
                            print(msg)
                            self.output('Unknown command. Use -h')
                            self.disconnect()
                    elif isinstance(msg, dict):
                        if 'type' in msg:
                            type = msg['type']
                            if 'method' in msg:
                                method = msg['method']
                                if 'payload' in msg:
                                    payload = msg['payload']
                                    if type == 'REQUEST':
                                        if method == 'MODINIT':
                                            self.ismodule = True
                                            self.module = payload
                                            self.pid = msg['pid']
                                            self.send('MODINIT', 'SINGLEREQUEST')

                                        elif method == 'VERSION':
                                            self.send('VERSION', VERSION)
                                        
                                        elif method == 'RUN':
                                            if not payload['workspace']:
                                                payload['workspace'] = v.pids[msg['pid']].workspace
                                            if moduleRun(payload['workspace'], payload['module']):
                                                self.send('RUN', True)
                                            else:
                                                self.send('RUN', False)

                                        elif method == 'GETWORKSPACE':
                                            self.send('GETWORKSPACE', v.pids[msg['pid']].workspace)

                                        elif method == 'MODULEEXISTS':
                                            if not payload['workspace']:
                                                payload['workspace'] = v.pids[msg['pid']].workspace
                                            if moduleExists(payload['workspace'], payload['module']):
                                                self.send('MODULEEXISTS', True)
                                            else:
                                                self.send('MODULEEXISTS', False)

                                        elif method == 'MODULEISRUNNING':
                                            if not payload['workspace']:
                                                payload['workspace'] = v.pids[msg['pid']].workspace
                                            if moduleIsRunning(payload['workspace'], payload['module']):
                                                self.send('MODULEISRUNNING', True)
                                            else:
                                                self.send('MODULEISRUNNING', False)

                                        elif method == 'INSTALL':
                                            if not payload['workspace']:
                                                payload['workspace'] = v.pids[msg['pid']].workspace
                                            if moduleInstall(payload['workspace'], payload['module']):
                                                self.send('INSTALL', True)
                                            else:
                                                self.send('INSTALL', False)

                                        elif method == 'REMOVE':
                                            if not payload['workspace']:
                                                payload['workspace'] = v.pids[msg['pid']].workspace
                                            if moduleRemove(payload['workspace'], payload['module']):
                                                self.send('REMOVE', True)
                                            else:
                                                self.send('REMOVE', False)

                                        elif method == 'KILL':
                                            if not payload['workspace']:
                                                payload['workspace'] = v.pids[msg['pid']].workspace
                                            if moduleKill(payload['workspace'], payload['module']):
                                                self.send('KILL', True)
                                            else:
                                                self.send('KILL', False)
                                        elif method == 'GETAPI':
                                            self.send('GETAPI',"http://" + mainconfig['API']['bind']+ ":"+str(mainconfig['API']['port'])+"/api")
                                            
                                        elif method == 'GLOBALEVENT':
                                            self.ismodule = True
                                            self.module = payload
                                            self.pid = msg['pid']
                                            if self.pid in v.pids:
                                                event_module = v.pids[self.pid].moduleident
                                                event_workspace = v.pids[self.pid].workspace
                                                event_pid = v.pids[self.pid].pid
                                                eventTrigger('GLOBALEVENT', {'module': event_module, 'workspace': event_workspace,'pid': event_pid}, payload)
                                            self.send('MODREQ', 'OK')

                                    elif type == 'PIPE':
                                        if method == 'MODPIPE':
                                            self.ismodule = True
                                            self.module = payload
                                            self.pid = msg['pid']
                                            if self.pid in v.pids:
                                                v.pids[self.pid].eventpipe = self
                                            self.send('MODINIT', 'PIPE')



                    else:
                        pass
                        #print("Nolist " + str(msg))
                        #self.sendraw("Your msg; " + str(msg))


            except Exception as err:
                print(err)
                try:
                    self.output('Error:' + err)
                except:
                    pass
                self.conn.close()
                break

    def getInput(self, query):
        self.send('INPUT', query)
        return self.conn.recv()

    def output(self, message):
        self.send('OUTPUT', message)

    def send(self, method, payload):
        self.conn.send({'method': method, 'payload': payload})

    def sendraw(self, message):
        self.conn.send(message)
        
    def disconnect(self):
        self.conn.close()

def is_float(string):
    try:
        float(string)
        return True
    except ValueError:
        return False

def is_int(string):
    try:
        int(string)
        return True
    except ValueError:
        return False

def is_url(url):
    return urlparse(url).scheme in ('http', 'https',)

def loadConfig():
    with open(os.path.join(os.path.join(pathMokka(), 'config', 'config.toml')), "r") as f:
        tomlraw = f.read()
    return tomllib.loads(tomlraw)

def pathMokka():
    return os.path.dirname(os.path.abspath(__file__))

def pathUser():
    return os.path.expanduser('~')

def pathBase():
    pb = os.path.join(os.path.expanduser('~'), 'mokkabase')
    if not os.path.isdir(pb):
        os.mkdir(pb)
    return pb

def pathTmpDir():
    pb = os.path.join(pathBase(), '.tmp')
    if not os.path.isdir(pb):
        os.mkdir(pb)
    return pb

def pathWorspace(workspace):
    pb = os.path.join(os.path.expanduser('~'), 'mokkabase', workspace)
    return pb

def pathModule(workspace, ident):
    pb = os.path.join(os.path.expanduser('~'), 'mokkabase', workspace, ident)
    return pb

def saveOptions(workspace, options):
    with open(os.path.join(pathWorspace(workspace),'options.json'), "w") as f:
        f.write(json.dumps(options))

def loadOptions(workspace):
    if os.path.isfile(os.path.join(pathWorspace(workspace),'options.json')):
        with open(os.path.join(os.path.join(pathWorspace(workspace),'options.json')), "r") as f:
            optionsraw = f.read()
        return json.loads(optionsraw)
    else:
        return {}
    
def setOption(workspace, module, option, value):
    workspace = workspace.upper()
    module = module.upper()
    option = option.upper()
    options = loadOptions(workspace)
    if not module in options:
        options[module] = {}
    options[module][option] = value
    saveOptions(workspace, options)

def getOption(workspace, module, option, default = None):
    workspace = workspace.upper()
    module = module.upper()
    option = option.upper()
    options = loadOptions(workspace)
    if module in options:
        if option in options[module]:
            return options[module][option]
    return default

def marketGet():
    with urlopen(mainconfig['MARKET']['url']) as f:
        tomlraw = f.read()
    return tomllib.loads(str(tomlraw.decode('utf-8')))

def marketSearch(term):
    market = marketGet()
    results = []
    for resmodule in market['MODULES']:
        if term in resmodule['ident']: results.append(resmodule)
        elif term in resmodule['title']: results.append(resmodule)
        elif term in resmodule['description']: results.append(resmodule)
    return results

def marketGetIdent(ident):
    market = marketGet()
    for resmodule in market['MODULES']:
        if ident == resmodule['ident']: return resmodule
    return False


def moduleGetConfig(source):
    with open(os.path.join(os.path.join(source, 'mokka.toml')), "r") as f:
        tomlraw = f.read()
    return tomllib.loads(tomlraw)

def moduleExists(workspace, ident):
    if os.path.isdir(os.path.join(pathWorspace(workspace),ident)):
        return True
    return False

def moduleIsRunning(workspace, ident):
    mident = workspace.upper() + '/' + ident.upper()
    if mident in v.modules:
        return True
    return False

def moduleInstall(workspace, source, client = False):
    if not os.path.isdir(pathWorspace(workspace.upper())):
        if client: client.output("Workspace " + workspace.upper() + ' does not exist')
        return False
    
    tmpdir = False

    marketResult = marketGetIdent(source)
    if marketResult:
        if client: client.output('Installing from Marketplace..')
        source = marketResult['path']

    if is_url(source):
        if not str(source).lower().endswith('.zip'):
            if client: client.output('Only ZIP files supported')
            return False
        fn = str(uuid.uuid4())
        try:
            urlretrieve(source, os.path.join(pathTmpDir(), fn + '.zip'))
        except:
            if client: client.output('Unable to download file')
            return False
        try:
            with zipfile.ZipFile(os.path.join(pathTmpDir(), fn + '.zip'), 'r') as zip_ref:
                zip_ref.extractall(os.path.join(pathTmpDir(), fn))
        except:
            if client: client.output('Unable to extract zip file')
            os.remove(os.path.join(pathTmpDir(), fn + '.zip'))
            return False

        os.remove(os.path.join(pathTmpDir(), fn + '.zip'))
        
        tmpdir = os.path.join(pathTmpDir(), fn)
        source = tmpdir      

    if os.path.isdir(source):
        if client: client.output('Installing from ' + source)
        err = moduleHasErrors(source)
        if err: 
            if client: client.output(err)
            if tmpdir: shutil.rmtree(tmpdir)
        else:
            if client: client.output('Source check OK.')
            config = moduleGetConfig(source)
            if moduleExists(workspace.upper(), config['GENERAL']['ident']):
                if client: client.output('Module already exists')
                if tmpdir: shutil.rmtree(tmpdir)
                return False
            shutil.copytree(source, os.path.join(pathWorspace(workspace.upper()), config['GENERAL']['ident'].upper()))
            shutil.copy(os.path.join(pathMokka(),'shared','mokkalib.py'), os.path.join(pathWorspace(workspace.upper()), config['GENERAL']['ident'].upper(), 'mokkalib.py'))
            if client: client.output('Creating virtual environment...')
            venv.create(os.path.join(pathWorspace(workspace.upper()), config['GENERAL']['ident'].upper()))
            if client: client.output('Installing PIP...')
            subprocess.check_call([os.path.join(pathWorspace(workspace.upper()), config['GENERAL']['ident'].upper(),'bin','python'), '-m' , 'ensurepip', '--default-pip'])            
            if 'INSTALL' in config:
                if 'piplibs' in config['INSTALL']:
                    for piplib in config['INSTALL']['piplibs']:
                        if client: client.output('Installing '+piplib+'...')
                        subprocess.check_call([os.path.join(pathWorspace(workspace.upper()), config['GENERAL']['ident'].upper(),'bin','python'), "-m", "pip", "install", piplib])
                if 'options' in config['INSTALL']:
                    for option in config['INSTALL']['options']:
                        if client: client.output('Setting option '+option+' = '+str(config['INSTALL']['options'][option]))
                        setOption(workspace.upper(), config['GENERAL']['ident'].upper(),option,config['INSTALL']['options'][option])
            
            if client: client.output('Module installed')
            return True
    else:
        if client: client.output(source + ' not found.')
        if tmpdir: shutil.rmtree(tmpdir)
        return False

def moduleExists(workspace, ident):
    if os.path.isdir(os.path.join(pathWorspace(workspace.upper()),ident.upper())):
        return True
    return False

def moduleRemove(workspace, ident):
    eventTrigger('REMOVEMODULE', False, {'workspace': workspace.upper(), 'module': ident.upper(), 'timestamp': time.time()})

    moduleKill(workspace, ident)
    if os.path.isdir(os.path.join(pathWorspace(workspace.upper()),ident.upper())):
        shutil.rmtree(os.path.join(pathWorspace(workspace.upper()),ident.upper()))
        return True
    return False

def moduleRun(workspace, ident):
    moduleKill(workspace, ident)
    if os.path.isdir(os.path.join(pathWorspace(workspace.upper()),ident.upper())):
        Module(workspace.upper(), ident.upper()).start()
        eventTrigger('RUN', False, {'workspace': workspace.upper(), 'module': ident.upper(), 'timestamp': time.time()})
        return True
    return False

def moduleGetLog(workspace, ident):
    mident = workspace.upper() + '/' + ident.upper()
    if mident in v.modules:
        return v.modules[mident].output

def moduleKill(workspace, ident):
    mident = workspace.upper() + '/' + ident.upper()
    if mident in v.modules:
        eventTrigger('KILLMODULE', False, {'workspace': workspace.upper(), 'module': ident.upper(), 'pt': mident, 'timestamp': time.time()})
        try:
            v.modules[mident].kill()
        except Exception as err:
            eventTrigger('ERRKILL', False, {'workspace': workspace.upper(), 'module': ident.upper(), 'pt': mident, 'msg': err, 'running': str(v.modules), 'timestamp': time.time()})
            return False
        return True
    return False


def moduleKillAll():
    for ident in v.modules:
        v.modules[ident].kill()

def moduleHasErrors(source):
    if os.path.isfile(os.path.join(source, 'mokka.toml')):
        try:
            with open(os.path.join(os.path.join(source, 'mokka.toml')), "r") as f:
                tomlraw = f.read()
            config = tomllib.loads(tomlraw)
            configok = False
            if 'GENERAL' in config:
                if 'title' in config['GENERAL']:
                    if 'ident' in config['GENERAL']:
                        if 'exec' in config['GENERAL']:
                            configok = True
                        else:
                            return "Invalid mokka.toml"    
                    else:
                        return "Invalid mokka.toml"    
                else:
                    return "Invalid mokka.toml"    
            else:
                return "Invalid mokka.toml"

            if configok:
                if not os.path.isfile(os.path.join(os.path.join(source, config['GENERAL']['exec']))):
                    return "Exec file is missing."
                return False
            
        except Exception as err:
            return "Invalid mokka.toml" + os.path.join(os.path.join(source, 'mokka.toml')) + str(err)
    else:
        return "mokka.toml missing"
    return False

def eventTrigger(method, module, payload):
    for pid in v.pids:
        if v.pids[pid].eventpipe:
            moduledata = {}
            if module:
                moduledata = module
            else:
                moduledata = False
            payload = {
                'method': method,
                'module': moduledata,
                'payload': payload
            }
            v.pids[pid].eventpipe.send(method, payload)
        pass

def setup():
    # Kill older instances by name
    pid = os.getpid()
    for p in psutil.process_iter():
        if p.name().lower() == 'python' or p.name().lower() == sys.executable.lower():
            cmdl = p.cmdline()
            try:
                if cmdl[0].lower().endswith('/python'):
                    if cmdl[1].lower() == 'mokkad':
                        if pid != p.pid:
                            print("Old instance of Daemon was terminated. Only one instance allowed.")
                            os.kill(p.pid,signal.SIGTERM)
            except:
                pass

    # Jump into program dir as CWD
    os.chdir(os.path.dirname(os.path.abspath(__file__)))

    # Create dir in user home dir
    cwd = pathBase()
    
    # Create Port-File
    with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as s:
        s.bind(('', 0))
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        port = s.getsockname()[1]
        with open(os.path.join(cwd,'.port'), "w") as f:
            f.write(str(port))

    # Create Secret-File
    secret = str(uuid.uuid4()) + '/' + str(time.time()) + '/' + str(random.randint(100000,999999999))
    with open(os.path.join(cwd,'.secret'), "w") as f:
        f.write(secret)

    return port, secret

def init():
    global mainconfig
    mainconfig = loadConfig()
    
    ssl._create_default_https_context = ssl._create_unverified_context

    port, secret = setup()
    print("IPC-Port: " + str(port))
    print("IPC-Secret: " + str(secret))
    server = IPCServer(port, secret)
    server.start()

    if mainconfig['API']['enabled']:
        try:
            v.apiserver = HTTPServer((mainconfig['API']['bind'], mainconfig['API']['port']), APIServer)
            print("API-Server: http://" + mainconfig['API']['bind']+ ":"+str(mainconfig['API']['port'])+"/api")
            v.apiserver.serve_forever()
        except:
            print("API-Server could not be started.")
            os._exit(1)
            pass

    while server.is_alive():
        time.sleep(0.1)

init()