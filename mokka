#!/usr/bin/python3

import os, sys, getopt
import time
import subprocess
import shutil
import signal
import logging
import threading

# Handle Ctrl-C Events
def sighandler(signum, frame):
    #os._exit(0)
    pass
signal.signal(signal.SIGINT, sighandler)


# Change to program path as working directory
os.chdir(os.path.dirname(os.path.abspath(__file__)))

# Insert own lib path
sys.path.insert(0, './libraries')

# Custom libraries
import m_vars as v
import m_commandline as opt
import m_path as pt
import m_pid as pid
import m_ipc as ipc
import m_handlers as handlers
import m_module as m


#Global Vars
v.client = False
v.server = False
v.modules = {
    'DEFAULT': {}
}
v.workspace = 'DEFAULT'

#Main
def main():

    if not pt.hasWritePermission(pt.pathAbsolute()):
        print("Application directory is not writable. Exiting.")
        os._exit(1)
    try:
        os.mkdir(pt.pathAbsolute() + '/workspaces')
        os.mkdir(pt.pathAbsolute() + '/workspaces/DEFAULT')
    except:
        pass

    #print(opt.getMethod())
    #print(opt.getValue('asd'))
    #print(opt.isParam('quak'))

    # Kill old instances
    if opt.getMethod() == "SHUTDOWN":
        pid.kill()
        pid.removefile()
        os._exit(0)

    # Start the service after killing old instances
    if opt.getMethod() == "RUNSERVICE":
        pid.kill()
        pid.write()
        # Create connect files
        ipc.createSecret(pt.pathAbsolute() + '/.ipctoken')
        ipc.createPort(pt.pathAbsolute() + '/.ipcport')
        # Start server
        v.server = ipc.startServer(handlers.serverHandler, ipc.getPort(pt.pathAbsolute() + '/.ipcport'), ipc.getSecret(pt.pathAbsolute() + '/.ipctoken'))

    #Other Methods given
    else:

        #Start the client and try to connect to service
        v.client = ipc.startClient(handlers.clientHandler, ipc.getPort(pt.pathAbsolute() + '/.ipcport'), ipc.getSecret(pt.pathAbsolute() + '/.ipctoken'))
        if not pid.check() and not v.client: #Service not available, so restart it with nohup
            if shutil.which('nohup') is not None:
                os.system("nohup "+sys.executable+" "+pt.pathScript() + " RUNSERVICE > /dev/null &")
            else:
                print("nohup is required. Exiting")
                os._exit(1)

            # Now try to connect
            retries = 0
            while retries < 10:
                time.sleep(0.2)
                v.client = ipc.startClient(handlers.clientHandler, ipc.getPort(pt.pathAbsolute() + '/.ipcport'), ipc.getSecret(pt.pathAbsolute() + '/.ipctoken'))
                if v.client: 
                    break
                retries += 1
        
        # Connection error?
        if not v.client:
            print("ERROR: Service not reachable")
            os._exit(1)

        # Main proc
    
    # If process is Server
    if v.server:
        pass

    # If process is Client
    elif v.client:
        
        if not opt.getMethod():
            print('Use mokka help')
            os._exit(1)
            pass
        elif opt.getMethod() == 'CONSOLE':
            handlers.protreq(v.client, 'COMMANDLINE', opt.commandlineoptions)
            s = ''
            while True:
                s = input()
                if s.upper() == "EXIT" or s.upper() == "Q":
                    os._exit(0)
                elif s.upper() == "SHUTDOWN":
                    handlers.protreq(v.client, 'INPUT', s)
                    time.sleep(0.2)
                    pid.removefile()
                    os._exit(0)
                handlers.protreq(v.client, 'INPUT', s)
        else:
            handlers.protreq(v.client, 'COMMANDLINE', opt.commandlineoptions)
            os._exit(0)



if __name__ == "__main__":        
    main()
