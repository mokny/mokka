#!/usr/bin/python3
import threading
import time
import uuid
import random
from multiprocessing.connection import Listener, Client
from contextlib import closing
import socket
import os
import signal
import psutil
import sys
import datetime
import shutil
import subprocess 

tlock = threading.Lock()
starttime = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

class Module(threading.Thread):
    def __init__(self, workspace, ident):  
        threading.Thread.__init__(self)
        self.workspace = workspace
        self.moduleident = ident
        self.output = []
        self.ps = False
        self.process = None

    def run(self):
        value = 'ping -c 10000 localhost' 
        try:
            os.environ["PYTHONUNBUFFERED"] = "1"
            self.process = subprocess.Popen(value.split(' '), stdout = subprocess.PIPE, stdin = subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, preexec_fn=os.setsid)#, cwd=pathModule(self.workspace, self.moduleident))
            self.ps = psutil.Process(self.process.pid)
            print(self.process.pid)
            while True:
                line = self.process.stdout.readline()
                self.process.stdout.flush()
                if not line:
                    break
                print(line.rstrip())
                self.output.append(line.rstrip())
                if len(self.output) > 10:
                    self.output = self.output[1:]
                #self.out(str(line.rstrip()))

            err = self.process.stderr.read()          
            if err:
                self.output.append(str(err))
                pass

            self.output.append('--END--')
        except Exception as err:
            print(err)
            self.output.append(str('-- END WITH ERR ' + str(err) + ' --'))
            pass



class IPCServer(threading.Thread):
    def __init__(self, port, secret):  
        threading.Thread.__init__(self)
        self.port = port
        self.secret = secret

    def run(self):
        address = ('127.0.0.1', self.port)     # family is deduced to be 'AF_INET'
        listener = Listener(address, authkey=str.encode(str(self.secret)))
        while True:
            c = IPCIncomingConnection(listener.accept())
            c.start()

class IPCIncomingConnection(threading.Thread):
    def __init__(self, conn):  
        threading.Thread.__init__(self)
        self.conn = conn
        self.workspace = 'DEFAULT'
        self.ismodule = False
        self.module = False
        
    def run(self):
        msg = ''
        while True:
            try:
                msg = self.conn.recv()
                with tlock:
                    if isinstance(msg, list):
                        if len(msg) > 0:
                            
                            # Quit the Daemon
                            if msg[0] == "-q":
                                self.disconnect()
                                os._exit(0)
                            
                            # Restart the Daemon
                            if msg[0] == "-r":
                                os.system("nohup "+sys.executable+" mokkad >/dev/null 2>&1 &")
                                self.disconnect()
                                os._exit(0)

                            # Version
                            if msg[0] == "-v":
                                self.output("Version 0")
                                self.disconnect()

                            # Help
                            elif msg[0] == "-h":
                                self.output('-h                 Help')
                                self.output('-q                 Quit MOKKA Daemon')
                                self.output('-s                 Enter Shell')
                                self.output('-v                 Version')
                                self.output('-w                 Create Workspace')
                                self.disconnect()
                            
                            # Modules
                            elif msg[0].lower() == "module" or msg[0].lower() == "mod":
                                if len(msg) >= 2:
                                    # Run moduke
                                    if msg[1].lower() == "run" or msg[1].lower() == "r":
                                        if len(msg) == 4:
                                            self.output('Running Module...')
                                            m = Module(msg[2], msg[3]).start()
                                            self.disconnect()

                            # Workspace
                            elif msg[0].lower() == "workspace" or msg[0].lower() == "ws":
                                if len(msg) >= 2:

                                    # Create workspace
                                    if msg[1].lower() == "create" or msg[1].lower() == "cr":
                                        if len(msg) == 3:
                                            workspace = msg[2].upper()
                                            if not workspace == '.' and not workspace == '..':
                                                if not os.path.isdir(pathWorspace(workspace)):
                                                    self.output("Creating Workspace " + workspace)
                                                    os.mkdir(pathWorspace(workspace))
                                                    self.output("Done.")
                                                else:
                                                    self.output("Workspace already exists.")
                                            else:
                                                self.output("Invalid workspace ident.")
                                        else:
                                            self.output("Invalid syntax. Use WORKSPACE CREATE <IDENT>")
                                    
                                    # Remove workspace
                                    elif msg[1].lower() == "remove" or msg[1].lower() == "rm":
                                        if len(msg) == 3:
                                            workspace = msg[2].upper()
                                            if not workspace == '.' and not workspace == '..':
                                                if os.path.isdir(pathWorspace(workspace)):
                                                    self.output("Removing Workspace " + workspace)
                                                    shutil.rmtree(pathWorspace(workspace))
                                                    self.output("Done.")
                                                else:
                                                    self.output("Workspace does not exist.")
                                            else:
                                                self.output("Invalid workspace ident.")
                                        else:
                                            self.output("Invalid syntax. Use WORKSPACE CREATE <IDENT>")
                                    
                                    # List workspaces
                                    elif msg[1].lower() == "list" or msg[1].lower() == "ls":
                                        self.output("Workspaces:")
                                        for workspace in os.listdir(pathBase()):
                                            if os.path.isdir(pathWorspace(workspace)):
                                                self.output(workspace)
                                        self.output("")

                                    elif msg[1].lower() == "help":
                                        self.output("WORKSPACE")
                                        self.output("   LIST or LS            - List all workspaces")
                                        self.output("   CREATE or CR <IDENT>  - Create a new workspace")
                                        self.output("   REMOVE or RM <IDENT>  - Remove a workspace")

                                    else:
                                        self.output("Invalid syntax. Use WORKSPACE HELP")
                                else:
                                        self.output("Invalid syntax. Use WORKSPACE HELP")
                                self.disconnect()

                            # Internal shell
                            elif msg[0] == "-s":
                                self.output(" ___ ___   ___   __  _  __  _   ____ ")
                                self.output("|   |   | /   \ |  |/ ]|  |/ ] /    |")
                                self.output("| _   _ ||     ||  ' / |  ' / |  o  |")
                                self.output("|  \_/  ||  O  ||    \ |    \ |     |")
                                self.output("|   |   ||     ||     \|     \|  _  |")
                                self.output("|   |   ||     ||  .  ||  .  ||  |  |")
                                self.output("|___|___| \___/ |__|\_||__|\_||__|__|")                              
                                self.output('Multi processing / IPC framework')
                                self.output('by Till Vennefrohne')
                                self.output('Daemon startet at ' + str(starttime) + ' / PID: ' + str(os.getpid()))
                                self.output('Welcome to the shell. Type Q to exit')
                                self.output('')
                                while True:
                                    response = self.getInput('> ').strip()

                                    if response.lower() == 'q':
                                        self.disconnect()
                                        break

                                    elif response.lower() == 'r':
                                        self.disconnect()
                                        os.system("nohup "+sys.executable+" mokkad >/dev/null 2>&1 &")
                                        os._exit(0)

                                    elif response.lower() == 'help':
                                        self.output('Q      Exit shell')
                                        self.output('R      Restart Daemon')

                                    else:
                                        self.output('Unknown command ' + response + '. Use HELP.')
                            
                            # Invalid command
                            else:
                                print(msg)
                                self.output('Unknown command. Use -h')
                                self.disconnect()

                        else:
                            print(msg)
                            self.output('Unknown command. Use -h')
                            self.disconnect()

            except Exception as err:
                print(err)
                try:
                    self.output('Error:' + err)
                except:
                    pass
                self.conn.close()
                break

    def getInput(self, query):
        self.send('INPUT', query)
        return self.conn.recv()

    def output(self, message):
        self.send('OUTPUT', message)

    def send(self, method, payload):
        self.conn.send({'method': method, 'payload': payload})

    def disconnect(self):
        self.conn.close()


def pathUser():
    return os.path.expanduser('~')

def pathBase():
    pb = os.path.join(os.path.expanduser('~'), 'mokkabase')
    if not os.path.isdir(pb):
        os.mkdir(pb)
    return pb

def pathWorspace(workspace):
    pb = os.path.join(os.path.expanduser('~'), 'mokkabase', workspace)
    return pb

def pathModule(workspace, ident):
    pb = os.path.join(os.path.expanduser('~'), 'mokkabase', workspace, ident)
    return pb

def setup():
    # Kill older instances by name
    pid = os.getpid()
    for p in psutil.process_iter():
        if p.name().lower() == 'python':
            cmdl = p.cmdline()
            try:
                if cmdl[0].lower().endswith('/python'):
                    if cmdl[1].lower() == 'mokkad':
                        if pid != p.pid:
                            print("Old instance of Daemon was terminated. Only one instance allowed.")
                            os.kill(p.pid,signal.SIGTERM)
            except:
                pass

    # Jump into program dir as CWD
    os.chdir(os.path.dirname(os.path.abspath(__file__)))

    # Create dir in user home dir
    cwd = pathBase()
    
    # Create Port-File
    with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as s:
        s.bind(('', 0))
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        port = s.getsockname()[1]
        with open(os.path.join(cwd,'.port'), "w") as f:
            f.write(str(port))

    # Create Secret-File
    secret = str(uuid.uuid4()) + '/' + str(time.time()) + '/' + str(random.randint(100000,999999999))
    with open(os.path.join(cwd,'.secret'), "w") as f:
        f.write(secret)

    return port, secret

def init():
    port, secret = setup()
    print("Port " + str(port))
    print("Port " + str(secret))
    server = IPCServer(port, secret).start()

init()